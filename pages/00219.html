<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ロータリエンコーダ用Pythonプログラム</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="icon" href="img/favicon.png" type="image/png">
</head>
<body>
<header>
</header>
<main>
  <h1>ロータリエンコーダ用Pythonプログラム</h1>
  <p align="right">2018年05月14日　カテゴリー：<a href="00182.html">Raspberry Pi</a></p>
  <hr class="title"><br>
  <a href="00181.html">RasPd1</a>でロータリーエンコーダを使っていましたが操作性がイマイチでしたので、もう少しエフェクター向けの動作となるようPythonプログラムを作り直しました。参考ページ→<a href="https://hawksnowlog.blogspot.jp/2017/01/raspberrypi-with-rotaryencoder-python.html" target="_blank">RaspberryPi + Python でロータリエンコーダを制御してみた</a><br>
<br>
▽回路図<br>
<img alt="03_219_1res.png" border="0" height="180" src="img/03_219_1res.png" width="400"/><br>
2つのスイッチ（AとB）のタイミングの違いを利用して回転方向を判断します。今回使用したのは秋月電子で購入したEC12E2420801というクリックありのものです。あまりチャタリングは発生しないようですが、念のためチャタリング対策のコンデンサと抵抗を挿入しました。一般にロータリーエンコーダの出力波形は下図のようになります。<br>
<img alt="03_219_2rep.png" border="0" height="180" src="img/03_219_2rep.png" width="460"/><br>
<br>
▽テストプログラム<br>
<code><pre>#!/usr/bin/env python<br>
# coding:utf-8<br>
<br>
import RPi.GPIO as GPIO<br>
from time import sleep<br>
<br>
Ap = 6 # Rotary_encoder_A<br>
Bp = 12 # Rotary_encoder_B<br>
GPIO.setwarnings(False)<br>
GPIO.setmode(GPIO.BCM)<br>
GPIO.setup(Ap,GPIO.IN)<br>
GPIO.setup(Bp,GPIO.IN)<br>
re_value = 0<br>
<br>
def rot(channel):<br>
    global re_value<br>
    if GPIO.input(Ap) == 0 :<br>
        cw = 0 # Crockwise or countercrockwise<br>
        Ac = 0 # Ap switching counter<br>
        Last_Bp = GPIO.input(Bp) # Bp status<br>
        for m in range(0,100):<br>
            if GPIO.input(Ap) == 1:<br>
                break<br>
            sleep(0.0005)<br>
        if Last_Bp == 0 and GPIO.input(Bp) == 1 :<br>
            cw = -1<br>
        if Last_Bp == 1 and GPIO.input(Bp) == 0 :<br>
            cw = 1 <br>
        for n in range (0,24):<br>
            Last_Ap = GPIO.input(Ap) # Ap status<br>
            sleep(0.002)<br>
            if Last_Ap == 1 and GPIO.input(Ap) == 0 :<br>
                Ac = Ac + 1<br>
        if Ac == 0:<br>
            re_value = re_value + cw * 1<br>
        elif Ac == 1:<br>
            re_value = re_value + cw * 4<br>
        elif Ac == 2:<br>
            re_value = re_value + cw * 8<br>
        elif Ac == 3:<br>
            re_value = re_value + cw * 16<br>
        else:<br>
            re_value = re_value + cw * 32<br>
        print re_value<br>
<br>
GPIO.add_event_detect(Ap,GPIO.FALLING,callback=rot,bouncetime=50)<br>
<br>
try:<br>
    while True:<br>
        sleep(60)<br>
except KeyboardInterrupt:<br>
    pass<br>
finally:<br>
    GPIO.cleanup()<br>
</pre></code>AピンがH→L（＝FALLING、1→0）となった時にrot関数が呼び出されます。「if GPIO.input(Ap) == 0 :」という当たり前のことが入れてありますが、以前バックグラウンドでPure Dataを起動していた際にGPIOの読み取りがおかしくなったため、念の為の処置です。<br>
<br>
まずAピンがHに戻るまでループを続け、Hになった瞬間のBピンの状態をみます。BピンがL→Hと変化していた場合は反時計回りで、逆の場合は時計回りと判断されます。次のループでは、Aピンが約50msの間に何回H→Lになったかカウントします。カウント数によって変化量が変わり、ロータリーエンコーダを速く回すほど値が大きく変化するということになります。<br>
<br>
ロータリーエンコーダの種類によってはうまく動作しないかもしれません。また、値の更新が50msごとなのでリアルタイム性が必要な用途には向いていないだろうと思います。<br>
<br>

</main>
<footer>
  <p><a href="../">ホーム</a></p>
  <p>Copyright &copy; 可燃ごみ箱</p>
</footer>
</body>
</html>